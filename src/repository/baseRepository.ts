/* eslint-disable @typescript-eslint/ban-ts-comment */
// Keep in mind that this file is automatically generated.
// You can change the content of this file, but it will be overwritten.

import _ from 'lodash';
import { Prisma } from '@prisma/client';
import {
  models,
  ModelName,
  ModelStructure,
  ModelScalarFields,
  AnyRecord,
  BaseOption,
  Find,
  CountArgs,
  Aggregate,
  ModelTypes,
} from './models';

/**
 * @param model - The model name
 */

export class BaseRepository<
  Where,
  Select,
  Include,
  Create,
  Update,
  Cursor,
  Order,
  Delegate,
  Scalar,
  Model
> {
  constructor(protected modelName: ModelName) {
    this.modelName = modelName;
  }

  // eslint-disable-next-line class-methods-use-this
  private extractCondition(conditions: Cursor | Where | number | string) {
    const dbCond = _.isObject(conditions) ? conditions : { id: _.toNumber(conditions) };

    return dbCond;
  }

  public async findAll(
    conditions: Where | number | string,
    filterQueryParams: AnyRecord = {},
    query: AnyRecord = {},
    option: Find<Select, Include, Cursor, Order, Scalar> = {}
  ) {
    const limit = +(query.limit === 'all' ? 0 : _.get(query, 'limit', 10));
    const offset = query.page && query.page > 0 ? limit * (query.page - 1) : 0;
    const otherOptions = _.omit(query, ['limit', 'offset', 'page']);

    const where = { ...this.extractCondition(conditions), ...filterQueryParams, ...otherOptions };

    return {
      // @ts-ignore
      rows: (await this.model.findMany({
        where,
        ...option,
        skip: offset,
        ...(limit > 0 && { take: limit }),
      })) as Model[],
      /* @ts-ignore */
      count: await this.count({ where }),
    };
  }

  public async findOne(
    conditions: Where | number | string,
    option: Find<Select, Include, Cursor, Order, Scalar> = {}
  ) {
    const where = this.extractCondition(conditions);

    // @ts-ignore
    return this.model.findFirst({ where, ...option }) as Promise<Model>;
  }

  public async findUnique(
    conditions: Cursor | number | string,
    option: BaseOption<Include, Select> = {}
  ) {
    const where = this.extractCondition(conditions);

    // @ts-ignore
    return this.model.findUnique({ where, ...option }) as Promise<Model>;
  }

  public async create(data: Create, option: BaseOption<Include, Select> = {}) {
    // @ts-ignore
    return this.model.create({ data, ...option }) as Promise<Model>;
  }

  public async update(
    conditions: Where | number | string,
    data: Update | Create,
    option: BaseOption<Include, Select> = {}
  ) {
    const where = this.extractCondition(conditions);

    // @ts-ignore
    return this.model.update({ data, where, ...option }) as Promise<Model>;
  }

  public async delete(conditions: Where | number | string) {
    const where = this.extractCondition(conditions);

    // @ts-ignore
    return this.model.deleteMany({ where }) as Promise<Prisma.BatchPayload>;
  }

  public async deleteOne(conditions: Where | number | string) {
    const where = this.extractCondition(conditions);

    // @ts-ignore
    return this.model.delete({ where }) as Promise<Model>;
  }

  public async updateOrCreate(
    conditions: Where | number | string,
    data: Create,
    option: Find<Select, Include, Cursor, Order, Scalar> = {}
  ) {
    const obj = await this.findOne(conditions, option);

    if (obj) return this.update(conditions, data, option);

    return this.create(data);
  }

  public async bulkCreate(data: Prisma.Enumerable<Create>, skipDuplicates = true) {
    // @ts-ignore
    return this.model.createMany({ data, skipDuplicates }) as Promise<Prisma.BatchPayload>;
  }

  public async bulkUpdate(where: Where, data: Prisma.Enumerable<Update>) {
    // @ts-ignore
    return this.model.updateMany({ data, where }) as Promise<Prisma.BatchPayload>;
  }

  public async count(
    conditions: Where | number | string,
    option: CountArgs<Select, Cursor, Order, Scalar> = {}
  ) {
    const where = this.extractCondition(conditions);

    // @ts-ignore
    return this.model.count({ where, ...option }) as Promise<number>;
  }

  public aggregate(
    conditions: Where | number | string,
    aggregator: Omit<
      // @ts-ignore
      Parameters<typeof this.model.aggregate>[0],
      'cursor' | 'take' | 'skip' | 'orderBy'
    >,
    option: Aggregate<Cursor, Order, Scalar> = {}
  ) {
    // @ts-ignore
    const aggregate = this.model.aggregate as Delegate['aggregate'];
    const where = this.extractCondition(conditions);

    if (_.isEmpty(aggregator)) {
      // @ts-ignore
      // eslint-disable-next-line no-param-reassign, no-underscore-dangle
      aggregator._count = true;
    }

    // @ts-ignore
    return aggregate({ where, ...aggregator, ...option }) as ReturnType<typeof aggregate>;
  }

  public get model(): Delegate {
    // @ts-ignore
    return models[this.modelName];
  }
}

const factory = <T extends ModelName>(model: T) =>
  new BaseRepository<
    ModelTypes[T]['Where'],
    ModelTypes[T]['Select'],
    ModelTypes[T]['Include'],
    ModelTypes[T]['Create'],
    ModelTypes[T]['Update'],
    ModelTypes[T]['Cursor'],
    ModelTypes[T]['Order'],
    ModelTypes[T]['Delegate'],
    ModelScalarFields<T>,
    ModelStructure[T]
  >(model);

export default factory;
